(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{348:function(v,e,t){"use strict";t.r(e);var _=t(8),o=Object(_.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"遇到问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#遇到问题"}},[v._v("#")]),v._v(" 遇到问题")]),v._v(" "),e("p",[v._v("页面运行过程中，随着使用时间的增长，页面操作越来越卡，并且会出现白屏和崩溃的情况")]),v._v(" "),e("h2",{attrs:{id:"确定是否存在内存泄漏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#确定是否存在内存泄漏"}},[v._v("#")]),v._v(" 确定是否存在内存泄漏")]),v._v(" "),e("p",[v._v("抓取内存快照进行对比来确定和排查内存泄漏相关情况")]),v._v(" "),e("h2",{attrs:{id:"常见的内存泄漏常见"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的内存泄漏常见"}},[v._v("#")]),v._v(" 常见的内存泄漏常见")]),v._v(" "),e("ol",[e("li",[v._v("未移除的监听事件")])]),v._v(" "),e("p",[v._v("当我们使用"),e("code",[v._v("addEventListener")]),v._v("进行事件监听时，在不需要的时候应当使用"),e("code",[v._v("removeEventListener")]),v._v("来移除监听")]),v._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[v._v("全局变量")])]),v._v(" "),e("p",[v._v("当我们定义了全局变量时在"),e("code",[v._v("window")]),v._v("上挂载变量时，变量在页面销毁前一直存在，我们应该避免定义全局变量，或者不使用时将此变量设置为空")]),v._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[v._v("未注销的observer")])]),v._v(" "),e("p",[v._v("当我们使用"),e("code",[v._v("MutationObserver")]),v._v("或者"),e("code",[v._v("ResizeObserver")]),v._v("时，在不需要的时候应当使用"),e("code",[v._v("disconnect")]),v._v("方法来取消监听")]),v._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[v._v("未移除的dom元素")])]),v._v(" "),e("p",[v._v("当我们使用"),e("code",[v._v("getElementById")]),v._v("或者"),e("code",[v._v("querySelector")]),v._v("等方法获取dom元素并将其赋值给某个变量时，在不需要时需要将此变量设置为空，避免当我们"),e("code",[v._v("removeChild")]),v._v("后此dom元素依旧存在内存中")]),v._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[v._v("未移除的计时器")])]),v._v(" "),e("p",[v._v("当我们使用"),e("code",[v._v("setTimeout")]),v._v("和"),e("code",[v._v("setInterval")]),v._v("时，在不需要时应该"),e("code",[v._v("clearTimeout")]),v._v("和"),e("code",[v._v("clearInterval")]),v._v(","),e("code",[v._v("setTimeout")]),v._v("和"),e("code",[v._v("setInterval")]),v._v("时并不一定会导致内存泄漏，但是及时clear会避免内存泄漏的出现")]),v._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[v._v("闭包中变量")])]),v._v(" "),e("p",[v._v("当一个函数A中定义了函数B，B中使用了函数A中声明的变量，在执行函数A结束时，应该将此变量设置为空")]),v._v(" "),e("ol",{attrs:{start:"7"}},[e("li",[v._v("未移除的事件订阅")])]),v._v(" "),e("p",[v._v("在vue中，当我们使用"),e("code",[v._v("$on")]),v._v("进行事件订阅后，在不需要时应该使用"),e("code",[v._v("$off")]),v._v("取消事件的订阅")]),v._v(" "),e("ol",{attrs:{start:"8"}},[e("li",[v._v("未销毁的vue实例")])]),v._v(" "),e("p",[v._v("在vue中，创建两个vue实例，将他们的dom通过"),e("code",[v._v("appendChild")]),v._v("等方式联系在一起，但是并没有创建两个vue实例的父子关系，当调用"),e("code",[v._v("removeChild")]),v._v("销毁时，需要调用"),e("code",[v._v("$destroy")]),v._v("将相对应的vue实例销毁")]),v._v(" "),e("ol",{attrs:{start:"9"}},[e("li",[v._v("iframe的onload事件")])]),v._v(" "),e("p",[v._v("交易中使用iframe.onload方法，改成document.addEventListener('load',XXX),在退出时使用document.removeEventListener('load',XXX)来销毁")])])}),[],!1,null,null,null);e.default=o.exports}}]);